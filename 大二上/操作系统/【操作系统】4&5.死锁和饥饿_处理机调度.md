<img src="https://counter.seku.su/cmoe?name=hiiragi_ansuke_learning&theme=r34"/>

# **4.处理机调度与死锁**

## **<font color=purple>1.高级\中级\低级调度</font>**

#### **0.多道程序环境与处理机调度(总体概述)**

>   **处理的作业类型:批量性作业/终端型作业**
>
>   **按照操作系统类型的调度分类:批处理调度/分时调度/实时调度/多处理机调度**
>   
>   **调度的重要性:1.决定了系统的运行性能 2.作业的提交和执行需要多级调度**
>   
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205102410000.png" alt="image-20241205102410000" style="zoom:50%;" />

#### **1.高级调度(作业/长程/宏观调度)**

>   **作用:**
>
>   >   **1.用于 决定 把外存上处于后备队列中的作业调入内存,**
>   >
>   >   **2.为它们 创建 进程和分配必要资源**
>   >
>   >   **3.将新创建的进程 插入 就绪队列中执行**
>   
>   **调度机制:批处理系统,而不是分时/实时系统**
>
>   **机制:多道程序度->确定作业量,调度算法->选择作业**

#### **2.低级调度(进程/短程调度)<font color=red>(最基本的,必须有)</font>**

>   **作用:**
>
>   >   **1.用来 决定 就绪队列哪个进程获得处理机**
>   >
>   >   **2.由分派程序 执行 把处理机进行分配**
>   
>   **调度机制:基本调度,所有类型操作系统均需配置**
>   
>   **分类:非抢占式(批处理系统)/抢占式(分时/实时/批处理均可)**
>
>   >   **非抢占式:处理机分配给进程直到完成或阻塞,实现简单开销小,但是不能完成紧急任务**
>>
>   >   **抢占式:允许抢占正在进行的进程,重新分配处理机,基于抢占原则(优先权/短作业优先..)**

#### **3.中级调度(中程调度)**

>   **作用:**
>
>   >   **将暂时不能运行的进程调至外存上去等待,如果空闲再调入**

## **<font color=purple>2.调度队列模型</font>**

#### **1.仅有进程调度的调度队列模型**

**(最基本的,进程一个一个完成)**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205103923459.png" alt="image-20241205103923459" style="zoom:50%;" />

#### **2.具有高级和低级调度的调度队列模型**

**(具有了作业顺序调度的功能)**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205104023237.png" alt="image-20241205104023237" style="zoom:50%;" />

#### **3.具有三级调度的调度队列模型**

**(具有了作业的挂起功能,即暂时阻塞)**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205104044077.png" alt="image-20241205104044077" style="zoom:50%;" />

## **<font color=purple>3.调度方式与算法选择准则</font>**

>   **量化标准:周转时间**
>
>   >   **周转时间:完成时间-<font color=red>到达时间(而不是开始时间)</font> **
>   >
>   >   **带权周转时间 = $\frac{周转时间}{服务时间}$**
>   >
>   >   **平均周转/带权周转时间:**$$T = \frac{1}{n}[\sum^n_{i=1} T_i] \quad W = \frac{1}{n}[\sum^{n}_{i=1}\frac{T_i}{S_i}]$$
>   >
>   >   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205105120870.png" alt="image-20241205105120870" style="zoom:50%;" />
>   >
>   >   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205105133846.png" alt="image-20241205105133846" style="zoom:50%;" />
>   >
>   >   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205105144192.png" alt="image-20241205105144192" style="zoom:50%;" />
>   >
>   >   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205105204176.png" alt="image-20241205105204176" style="zoom:50%;" />
>
>   **其它的bullshit:响应时间快/系统吞吐量高/处理机效率高/资源平和利用**

## **<font color=purple>4.调度算法</font>**

#### **1.(FCFS)先来优先服务**

>   **<font color=red>先来先服务,有利于长作业(进程),有利于CPU繁忙型作业(进程)</font>**
>
>   **不利于短作业(进程),不利于IO繁忙型作业(进程)**
>   
>   ![image-20241205110316507](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205110316507.png)

***

#### **2.(SJF)进程(短作业) 优先服务**

>   **基本思想:选取<font color=red>服务时间最短的</font><font color=purple>若干道</font>作业装入内存**
>
>   >   **适用于:单道批处理系统/多道批处理系统**
>   
>   **<font color=navy>特点:降低平均等待时间/提高吞吐量/不利于长作业/没考虑特权作业/服务时间不确定</font>**
>   
>   >   **如果是交互式作业:在IO操作之后,仅运行很短时间**
>   >
>   >   **如果是批处理作业:在IO操作之后,可能运行很长时间**
>   
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\bf568870a72caf54eb2f17116141b8c.jpg" alt="bf568870a72caf54eb2f17116141b8c" style="zoom:33%;" />
>   
>   >   **FCFS的顺序:ABCDE**
>   >
>   >   **SFJ的顺序:ADBEC**
>   >
>   >   **<font color=red>SJF需要注意的是,只有到达了才可选(不是B开始),不能只看服务时间</font>**
>   >
>   >   **了解即可:SRTF**
>   >
>   >   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205112722374.png" alt="image-20241205112722374" style="zoom:25%;" />

***

#### **3.(FPF)高优先权 优先调度(<font color=navy>一般都是抢占型的</font>)**

>   **基本思想:照顾紧迫性作业,根据优先级进行分配**
>
>   **分类:非抢占式优先权算法/抢占式优先权调度算法**
>   
>   **优先权类型:静态优先权/动态优先权**
>   
>   ![image-20241205113232944](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205113232944.png)
>   
>   >   **<font color=red>抢占式FPF:</font>**
>   >
>   >   ![image-20241205113257721](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205113257721.png)
>   >
>   >   ![image-20241205113503507](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205113503507.png)
>   >
>   >   **<font color=red>非抢占式FPF:</font>**
>   >
>   >   ![image-20241205113322599](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205113322599.png)
>   >
>   >   ![image-20241205113514789](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205113514789.png)
>   >
>   >   **<font color=red>抢占式和非抢占式的比较</font>**
>   >
>   >   ![image-20241205113621813](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205113621813.png)

***

#### **4.(HRRN)高响应比 优先调度**

>   **基本思想:短作业优先调度算法+动态优先权机制**
>
>   **<font color=red>优先权(动态比$R_p$) = $\frac{等待时间+要求服务时间}{要求服务时间}$</font>**
>   
>   **特点:短作业和先后次序的兼顾,且不会使长作业长期得不到服务**
>   
>   ![image-20241205131748761](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205131748761.png)
>   
>   **流程:**
>   
>   >   **时间0:$P_1$到达,$P_1$执行**
>   >
>   >   **时间1:$P_2$到达,$R_2 = \frac{(1-1)+3}{3} = 1.0$,但是要等$P_1$**
>   >
>   >   **时间2:$P_1$执行完成,$P_2,P_3$均到达,计算$R_2 = \frac{(5-1)+3}{3} \approx 2.33 \quad R_3 = \frac{(5-2)+2}{2} = 2.5$,执行$P_3$** 
>   >
>   >   **<font color=purple>所以执行顺序为:$P_1 , P_3 , P_2$</font>**

***

#### **5.(RR)时间片轮转 调度算法**

>   **基本思想:先来先服务排队+时间片及时钟中断**
>
>   **<font color=red>时间片大小的确定:</font>系统对响应时间的要求,就绪队列中进程的数量,系统能力**
>   
>   ```TXT
>   		A B C D E
>   到达时间 0 1 2 3 4
>   服务时间 4 3 4 2 4
>   
>   (q=1)                                (q=4)退化成FCFS
>   时刻  执行(剩余) 进程就绪队列(<-)         时刻  执行(剩余)       进程就绪队列(<-)
>   0     A(4-1=3)     A^                 0     A(4-4=0)           ABCDE
>   1     B(3-1=2)     BA^                4     B(3-3=0)C(4-1=3)   BCDE
>   2     A(3-1=2)     ACB^(先入C,再调B)   8     C(3-3=0)D(2-1=1)   CDE
>   3     C(4-1=3)     CBDA^(先入D,再调A)  12    D(1-1=0)E(4-3=1)    DE
>   4     B(2-1=1)     BDAEC(先入E,再调C)  16    E(1-1=0)            E
>   5     D(2-1=1)     DAECB(调B)         17    无                  NULL
>   6     A(2-1=1)     AECBD(调D)         // 所以(q=4)一共需要17时钟
>   7     E(4-1=3)     ECBDA(调A)
>   8     C(3-1=2)     CBDAE(调E)
>   9     B(1-1=0)     BDAEC(调C)
>   10    D(1-1=0)     DAEC(删B)
>   11    A(1-1=0)     AEC(删D)
>   12    E(3-1=2)     EC(删A)
>   13    C(2-1=1)     CE(调E)
>   14    E(2-1=1)     EC(调C)
>   15    C(1-1=0)     CE(调E)
>   16    E(1-1=0)     E(删C)
>   17    无           NULL
>   // 所以(q=1)时一共需要 17时钟
>   ```

****

#### **6.多级队列 调度算法**

>   **基本思想:作业性质分类排列,不同队列不同调度**
>
>   **目的:多操作系统的调度/不同类型作业的性质应该区别调度**
>   
>   **做法:优先权方式/前后台方式**

***

#### **7.多级反馈队列 调度算法**

>   **基本思想:设置多个就绪队列并赋予不同优先级,FCFS和RR算法结合**
>
>   **目的:通过stacking试图消除局限性**

***

#### **8.实时调度算法 分类**

>   **1.实时任务性质的不同"硬实时算法/软实时算法"**
>
>   **2.调度方式的不同:抢占式/非抢占式调度**
>   
>   **3.调度面向的实时任务组:静态调度/动态调度**
>   
>   **4.基本调度策略:FCFS/RR**
>   
>   **5.多处理机环境:集中式调度/分布式调度**

##### **1.(EDF)最早截止时间优先调度算法**

>   **人话:进程离ddl越近越先调度(低优先级可能饿死,需要适量抢占)**
>
>   **<font color=red>开始截止时间:进程要在它之前完成</font>**
>   
>   >   ***
>   >
>   >   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205142208944.png" alt="image-20241205142208944" style="zoom:50%;" />
>   >
>   >   >   **(顺序为1342,看开始截止时间即可)**
>   >
>   >   ***
>>
>   >   
>>
>   >   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205142506093.png" alt="image-20241205142506093" style="zoom:50%;" />
>   >
>   >   **要求:周期型任务,在下一个同类进程开始前,之前同一类的进程必须完成,否则会消失**
>   >
>   >   ```TXT
>   >   A类任务:20ms出现一个,10ms解决一个
>   >   B类任务:50ms出现一个,25ms解决一个
>   >   
>   >   时刻  选择    原因                    任务
>   >   0     A1     只有A1                  A1(10-10=0)
>   >   10    B1     A类任务没来,先做B1        B1(25-10=15)
>   >   20    A2     A2出现,并且截止时间短,抢占 A2(10-10=0)
>   >   30    B1     A2结束                  B1(15-10=5)
>   >   40    B1     A3出现,但是B1的截止时间短  B1(5-5=0)
>   >   45    A3     B1结束,开始A3            A3(10-5=5)   
>   >   50    A3     B2出现,但是A3截止时间短    A3(5-5=0)
>   >   55    B2     A3结束,开始B2            B2(25-5=20ms)...
>   >   ```

##### **2.(LLF)最低松弛度优先调度算法**

>   **<font color=red>松弛度计算:截止时间-<font color=purple>服务时间(分段做会减少)</font>-当前时间</font>**
>
>   >   **$B_1$在0处的松弛度为:50-25-0=25,<font color=purple>但是如果执行了20ms,就是50-5-0=45</font>**
>   >
>   >   **$A_1$在0处的松弛度为:20-10-0=10**
>   >
>   >   **(松弛度为0意味着此时刻到截止时间,刚好等于服务时间,需要立刻开始)**
>   >
>   >   **<font color=navy>第二行的进程波形图就是答案</font>**
>   >
>   >   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\0d733e1b4231193fc0a1e82dcb79278.jpg" alt="0d733e1b4231193fc0a1e82dcb79278" style="zoom:33%;" />

## **<font color=purple>5.死锁产生以及处理策略</font>**

#### **1.死锁的基本概念**

>   **定义:在多道程序中,并发执行 的多个进程,因抢占资源产生的僵局(无外力不可解除)**
>
>   **分类:资源(可剥夺资源/不可剥夺资源)(可重用资源/消耗性资源)**

#### **2.死锁产生的原因**

##### **1.竞争资源**

>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205145502162.png" alt="image-20241205145502162" style="zoom:55%;" />

##### **2.进程推进次序非法**

>   **解释:4号线越过对角线,导致进程P1P2都申请R1,又都申请R2**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205145650291.png" alt="image-20241205145650291" style="zoom:55%;" />

#### **<font color=red>3.死锁产生的必要条件</font>**

>   **1.互斥条件:资源排它性使用**
>
>   **2.请求和保持状态:请求未果还抢占资源**
>   
>   **3.不剥夺条件:在已获得资源未使用完前不能被剥夺**
>
>   **4.进程-资源产生环:**

#### **4.处理死锁的基本方法**

>   **1.预防死锁:破坏必要条件**
>
>   **2.避免死锁:资源动态分配前,检查是否为安全状态**
>   
>   **3.检测死锁:运行过程中检测死锁,并确定好相关资源和进程**
>
>   **4.解除死锁:撤销或挂起进程,进行资源再分配**

#### **5.死锁的预防**

>   **1.一次性申请(而不是请求和保持)**
>
>   >   **缺点:(简单安全)(资源浪费/进程延迟)**
>   
>   **2.主动释放(得不到满足应该释放)**
>
>   >   **缺点:实现复杂/代价大/进程周转时间延长/系统开销增加**
>
>   **3.有序申请(而不是环路等待)**
>   
>   >   **缺点:资源次序不灵活/浪费硬件资源**

#### **6.死锁的检测与解除**

>   **<font color=red>死锁定理(检测):系统状态S为死锁状态的充要条件:该状态下的资源分配图是不可完全化简的</font>**
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205153633317.png" alt="image-20241205153633317" style="zoom:50%;" />
>   
>   **(解除):1.剥夺其它进程足够数量资源给死锁进程  2.撤销死锁进程(全部or逐个)**

## **<font color=purple>6.死锁避免与银行家算法</font>**

#### **1.死锁避免思想**

**允许进程动态申请资源,并且分配之前就安全性进行检查,不安全则拒绝分配**

#### **2.死锁避免基本概念**

>   **安全状态:系统可以按照某种序列为每个进程分配其所需资源,使每个进程能顺利完成**
>
>   **不安全状态:系统无法找到一个安全分配的序列**
>
>   **死锁和安全状态的关系:没有必然关系,但是<font color=red>安全状态肯定不会死锁</font>**

#### **3.银行家算法数据结构**

>   **1.可利用资源向量/请求向量[M]:**
>
>   >   **$Available[j]=k\quad$表示系统有k个$R_j$类资源**
>   >
>   >   **$Request_i [j]=k\quad$表示进程$P_i$请求k个$R_j$类资源**
>
>   **2.最大需求矩阵/分配矩阵/需求矩阵[n,m]**
>
>   >   **$Max[i,j]=k\quad$表示系统现有k个$R_j$类资源**
>   >
>   >   $Allocation[i,j] = k\quad$**表示进程$P_i$已有k个$R_j$类资源**
>   >
>   >   $Need[i,j]=k\quad$**表示进程$P_i$尚需k个$R_j$类资源**
>
>   **3.工作向量[m]/Finish布尔向量[n]**
>
>   >   $Work[j]=k\quad$**表示系统可以提供k个$R_j$类资源**
>   >
>   >   $Finish[i]\quad$**表示进程$P_i$可否拥有足够资源完成运行**

#### **4.银行家算法主体**

>   **1.进程$P_i$发出资源请求$Request_i$**
>
>   **2.若$Request_i > Need[i] \quad$出错返回<font color=red>每个进程的资源请求不能超过它的需求。</font>**
>
>   **3.若$Request_i > Available \quad$,则应使$P_i$等待并返回<font color=navy>(需要的资源少于系统拥有的资源,等待)</font>**
>
>   **4.系统试探满足$P_i$请求,做出以下修改:**
>
>   >   $Available = Available - Request_i$**(系统拥有的资源减少)**
>   >
>   >   $Allocation[i] = Allocation[i] + Request_i$**(进程拥有的资源增加)**
>   >
>   >   $Need[i] = Need[i] - Request_i$**(进程需要的减少)**
>
>   **5.若资源安全执行分配,否则恢复试探前状态,并等待**

#### **5.银行家算法举例😊**

>   ```TXT
>   // MAX:进程需要的资源
>   // Allocation:目前已经拥有的资源
>   // Need:进程需要的资源(MAX - Allocation)
>   // Work:目前资源可用的(会随着进程的解决逐渐增加)
>   // A+W:Allocation+Work,当前进程执行后可用的资源,算好了以后誊到下一个进程的Work
>   // Finish:Ture或False
>   
>   ====================================================================
>   (银行家算法:1 安全性序列)
>   ====================================================================
>   进程    MAX    Allocation   Need    Work   A+W(New Avai)   Finish
>   P0    7 5 3    0 1 0       7 4 3   
>   P1    3 2 2    2 0 0       1 2 2   
>   P2    9 0 2    3 0 2       6 0 0   
>   P3    2 2 2    2 1 1       0 1 1   
>   P4    4 3 3    0 0 2       4 3 1   
>   ====================================================================
>   进程    MAX    Allocation   Need    Work   A+W(New Avai)   Finish
>   P0    7 5 3    0 1 0       7 4 3   7 4 5    7 5 5          True(4)
>   P1    3 2 2    2 0 0       1 2 2   3 3 2    5 3 2          True(1)
>   P2    9 0 2    3 0 2       6 0 0   7 5 5    10 5 7         True(5)
>   P3    2 2 2    2 1 1       0 1 1   5 3 2    7 4 3          True(2)
>   P4    4 3 3    0 0 2       4 3 1   7 4 3    7 4 5          True(3)
>   
>   // Available[A,B,C] = {10,5,7} 表示系统拥有的资源
>   // T0_Available[A,B,C] = {3,3,2} 表示系统T0时刻分配给进程后剩余可用的资源
>      // 求法 Available - Allocation(ALL)
>   // 所以安全分配序列<P1,P3,P4,P0,P2>
>   
>   
>   ====================================================================
>   (银行家算法:2 假设其中申请小于总需求)
>   ====================================================================
>   进程    MAX    Allocation   Need    Work   A+W(New Avai)   Finish
>   P0    7 5 3    0 1 0       7 4 3   
>   P1    3 2 2    2 0 0       1 2 2   
>   P2    9 0 2    3 0 2       6 0 0   
>   P3    2 2 2    2 1 1       0 1 1   
>   P4    4 3 3    0 0 2       4 3 1  
>   ====================================================================
>   进程    MAX    Allocation    Need          Work     A+W(New Avai)    Finish
>   P0    7 5 3    0 1 0        7 4 3         7 4 5    7 5 5             True(4)
>   P1    3 2 2    2 0 0(3 0 2) 1 2 2(0 2 0)  2 3 0    4 3 0             True(1)
>   P2    9 0 2    3 0 2        6 0 0         7 5 5    10 5 7            True(5)
>   P3    2 2 2    2 1 1        0 1 1         5 3 2    7 4 3             True(2)
>   P4    4 3 3    0 0 2        4 3 1         7 4 3    7 4 5             True(3)
>   // T1时刻Available[A,B,C] = {3,3,2}->{2,3,0}(经过t1以后) 
>   // 进程P1发出资源请求 Request_t1(1,0,2)＜Need1(1,2,2)
>   // 所以安全分配序列<P1,P3,P4,P0,P2>
>   
>   
>   ====================================================================
>   (银行家算法:3 假设其中申请小于总需求)
>   ====================================================================
>   进程    MAX    Allocation   Need    Work   A+W(New Avai)   Finish
>   P0    7 5 3    0 1 0       7 4 3   
>   P1    3 2 2    2 0 0       1 2 2   
>   P2    9 0 2    3 0 2       6 0 0   
>   P3    2 2 2    2 1 1       0 1 1   
>   P4    4 3 3    0 0 2       4 3 1  
>   
>   // T3时刻Available[A,B,C] = {2,3,0} 
>   // 进程P4发出资源请求 Request_t4(3,3,0)＜Need1(4,3,1)
>   // 但是(3,3,0)>{2,3,0},直接拒绝,让P4等待
>   
>   ====================================================================
>   (银行家算法:4 假设其中申请小于总需求)
>   ====================================================================
>   进程    MAX    Allocation     Need     Work    A+W(New Avai)   Finish
>   P0    7 5 3    0 1 0(0 3 0)  7 4 3                            False(0)
>   P1    3 2 2    2 0 0         1 2 2                            False(0)
>   P2    9 0 2    3 0 2         6 0 0                            False(0)
>   P3    2 2 2    2 1 1         0 1 1                            False(0)
>   P4    4 3 3    0 0 2         4 3 1                            False(0)
>   
>   // T3时刻Available[A,B,C] = {2,3,0} 
>   // 进程P0发出资源请求 Request_t0(0,2,0)＜Need1(7,4,3)
>   // 尝试,未找到
>   ```

## **Homework!!!**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\1e5caf561b7544f52fe2a277106d67d.jpg" alt="1e5caf561b7544f52fe2a277106d67d" style="zoom:80%;" />

```TXT
进程	 MAX	Allocation    Need	  Work		A+W			Finish		
P1	  5 5 9		2 1 2	   3 4 7		 
P2	  5 3 6		4 0 2      1 3 4	  		 
P3	  4 0 11	4 0 5	   0 0 6		 
P4	  4 2 5 	2 0 4	   2 2 1		 
P5	  4 2 4     3 1 4	   1 1 0	 
一共:(17,5,20)
T0剩余:2 3 3
==========================================================================================================================
1.T0是否是安全状态
进程	 MAX	Allocation    Need	    Work		A+W			Finish		
P1	  5 5 9		2 1 2	   3 4 7	 15 4 18     17 5 29      True(5)	 
P2	  5 3 6		4 0 2	   1 3 4 	 4 3 7       8 3 9        True(2)
P3	  4 0 11	4 0 5	   0 0 6	 11 4 13     15 4 18      True(4)	 
P4	  4 2 5 	2 0 4	   2 2 1	 4 2 5		 4 3 7		  True(1)        
P5	  4 2 4     3 1 4	   1 1 0     8 3 9		 11 4 13	  True(3)
T0:2 3 3
// 心得:
	对于第一个进程,如果可行,T0+allocation
	对于之后的进程,如果可行,上一个A+W转移到Work,Work+当前的Allocation
	
==========================================================================================================================
2.T0时,T2提出[0,3,4],是否能实现?
进程	 MAX	Allocation    Need	    Work		A+W			Finish		
P1	  5 5 9		2 1 2	   3 4 7		 
P2	  5 3 6		4 0 2      1 3 4	  		 
P3	  4 0 11	4 0 5	   0 0 6		 
P4	  4 2 5 	2 0 4	   2 2 1		 
P5	  4 2 4     3 1 4	   1 1 0
一共:(17,5,20)
T0剩余:2 3 3
答:Request(0,3,4)>Available(2,3,3,)Request不合法
==========================================================================================================================
3.T0时,T4提出[2,0,1],是否能实现?
进程	 MAX	Allocation     Need	       		 Work		A+W			Finish		
P1	  5 5 9		2 1 2	    3 4 7		      4 3 7      6 4 9        True(2)
P2	  5 3 6		4 0 2       1 3 4	  		  10 4 14    14 4 16      True(4)
P3	  4 0 11	4 0 5	    0 0 6		      6 4 9      10 4 14      True(3)
P4	  4 2 5 	2 0 4(4 0 5)2 2 1(0 2 0)      0 1 2      4 3 7        True(1)   
P5	  4 2 4     3 1 4	    1 1 0             14 4 16    17 5 20      True(5)
一共:(17,5,20)
T0剩余:2 3 3(0 3 2)
答:
	Request_T4(2,0,1) < Available(2,3,3)
	Request_T4(2,0,1) < Need_T4(2,2,1)
	Therefore:
	Allocation_T4:(2 0 4) + (2 0 1) = (4 0 5)
	Need_T4:(2 2 1) - (2 0 1) = (0 2 0)
	Allocation:(2 3 3) - (2 0 1) = (0 3 2)
	...
答:正确的序列:41325
// 心得:
	对于第一个进程,应该是(0 3 2)-(0 2 0)=(0 1 2)设置为work
```

```txr
n个进程,设共享资源的最大需求量为x(0<=x<=m),由于每个进程的最多申请x个,
最差情况,每个资源都申请了(x-1)个资源,都要抢最后一个,此时剩余m-(x-1)n

当m-(x-1)n 大于等于1时,就不会发生死锁(最后一类资源的个数大于1)
经过变形,即 nx小于等于(m+n-1),就不会死锁
转换为自然语言就是 所有进程的最大需求量小于 m+n,就不会发生死锁
```



