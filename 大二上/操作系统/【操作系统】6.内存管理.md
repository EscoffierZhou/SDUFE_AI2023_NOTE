![img](https://counter.seku.su/cmoe?name=hiiragi_ansuke_learning&theme=r34)

# **6.内存管理**



## **<font color=purple>1.内存管理概述</font>**

#### **1.存储器层次结构**

>   <img src="assets\image-20241205195906511.png" alt="image-20241205195906511" style="zoom:50%;" />

#### **2.用户程序处理过程**

>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205195950151.png" alt="image-20241205195950151" style="zoom:50%;" />

##### *😇**实模式和保护模式下地址转换**

**内存的管理方式:实模式和保护模式:**

>   **给定地址$DS:SI = 0x200:0x0230$**(段寄存器:偏移地址)
>
>   >   **<font color=red>$线性地址的计算方法 = (段寄存器值 << 4)+偏移量(固定值0x0230)$</font>**
>>
>   >   $\because \ DS = 0x200 \ SI = 0x0230 $
>>
>   >   $\therefore 0x200 << 4=0x02000 \quad 0x02000+0x0230=0x02230$
>   >
>   >   **<font color=red>(0x200 = (0x0) 0x2 0x0 0x0  = 0000 0010 0000 0000 )</font>**
>   >
>   >   **<font color=red>左移4位以后:0010 0000 0000 0000->0x2000</font>** 
>   
>   **实模式下地址转换: $0x0200 << 4 + 0x0230 = 0x02230$<font color=navy>线性地址</font>**
>   
>   **保护模式下地址转换: $0x0200 = (0000 \ 0010 \ 0000 \ 0000)$<font color=navy>(直接写成16进制)</font>**
>   
>   ***
>   
>   **<font color=purple>如果没有启动分页(保护模式):使用线性地址</font>**
>   
>   **<font color=purple>如果启动分页(保护模式):使用线性地址的映射</font>**
>   
>   >   **页表:线性地址映射到物理地址,分为 页目录 和 页表**
>   >
>   >   (x86中,高10位用于索引页目录,中间10位用于索引页表,低12位用于页内偏移)
>   
>   ```txt
>   // 十进制转十六进制查看表
>   0 -> 0000
>   1 -> 0001
>   2 -> 0010
>   3 -> 0011
>   4 -> 0100
>   5 -> 0101
>   6 -> 0110
>   7 -> 0111
>   8 -> 1000
>   9 -> 1001
>   A -> 1010
>   B -> 1011
>   C -> 1100
>   D -> 1101
>   E -> 1110
>   F -> 1111
>   只要记住每个16进制数字对应的4位二进制形式，就能快速进行转换。
>   其他例子：
>   0xF -> 1111
>   0x1A -> 0001 1010
>   0x7B -> 0111 1011
>   ```

#### **3.程序的链接**

##### **1.链接过程**

**根据外部访问符号名表,将编译得到的目标模块以及需要的库函数,包装成一个模块**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241205211556016.png" alt="image-20241205211556016" style="zoom:50%;" />

##### **2.关键变化**

>   **修改相对地址:修改为调用的最终位置(最后的物理位置)`**
>
>   **变换外部调用符号:解析变量名并且填充实际地址**

##### **3.链接方式**

>   **静态链接方式:可执行文件\难以实现内存模块共享**
>
>   **装入时动态链接:便于软件的修改和更新\便于实现目标模块的共享**
>
>   **运行时动态链接:推迟执行时间,有利于内存的有效利用**

##### **4.程序的装入**

###### **1.基本目标**

**由装入程序将装入模块载入到内存<font color=navy>(装入位置/地址变换及时机)</font>**

###### **<font color=red>2.关键概念</font>**

>   **<font color=purple>相对地址:相对于某个基地址的偏移量。</font>**
>
>   **<font color=purple>绝对地址:程序中实际的物理内存地址</font>**
>
>   **<font color=purple>重定位寄存器:重定位寄存器用于存储程序的基地址</font>**
>
>   >   **<font color=navy>在程序执行时可以对程序中的相对地址进行动态转换，将相对地址转换为绝对地址。</font>**

###### **3.装入方式**

>   **绝对装入方式(单道程序环境):<font color=navy>程序的起始地址在编译时就已经确定</font>**
>
>   **静态可重定位装入方式(多道程序环境):**
>
>   >   **<font color=navy>程序可以在加载时重定位，即可以将程序加载到不同的内存地址。</font>**
>
>   **动态运行时装入方式(运行中移动位置)**
>   
>   >   **<font color=navy>程序在程序运行时动态频繁切换地址</font>**
>   
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206082647093.png" alt="image-20241206082647093" style="zoom:50%;" />

###### **4.重定位**

**程序装入或执行时对装入模块中的程序指令,修改它们地址的过程**

>   **静态重定位:由重定位装入程序,在将装入模块装入内存时一次性完成重定向**
>
>   >   **<font color=red>需要连续存储空间x,装入后不能移动</font>**
>
>   **动态重定位:需要特殊硬件支持,保证地址转换不会影响执行执行速度**
>
>   >   **<font color=navy>便于动态链接和代码共享</font>(由图可见,是相对地址+重定位寄存器)**
>   >
>   >   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206160109912.png" alt="image-20241206160109912" style="zoom:33%;" />

##### **5.操作系统内存管理功能要求**

>   **1.内存分配:各得其所,提高效率(可用连续分配/离散分配方式)**
>
>   **2.地址映射:逻辑地址转换为物理地址,与分配方式相关**
>
>   **3.内存保护:基于地址的保护\存取访问控制保护**
>
>   **4.内存扩充:覆盖技术\对换技术\虚拟存储技术**

***

## **<font color=purple>2.连续分配存储管理方式</font>**

#### **1.单一连续分配存储管理**

>   **内存划分:系统区 用户区(仅驻留一道程序)**
>
>   **技术:静态链接和动态重定位技术**
>   
>   **局限:单任务/单用户操作系统**
>   
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206161744120.png" alt="image-20241206161744120" style="zoom:50%;" />

#### **2.固定分区分配存储管理**

>   **内存划分:用户区分为若干固定区域,每个分区可装入一道作业**
>
>   **技术:分区说明表与内存分配算法**
>   
>   **局限:可用于多道程序存储管理**
>   
>   **<font color=navy>(第n个分区号 = $大小_{n-1}$ + $始值_{n-1}$)</font>**
>   
>   
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206162108743.png" alt="image-20241206162108743" style="zoom:50%;" />
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206162127972.png" alt="image-20241206162127972" style="zoom:50%;" />
>   
>   ![image-20241206162601759](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206162601759.png)
>   
>   >   **1.600MB + 1200MB + 800MB = 2600MB<4000MB 所有作业都能加载**
>   >
>   >   **作业 A：600MB，可以加载到第一个分区（1GB）中。**
>   >
>   >   **作业 B：1.2GB，<font color=red>不可以加载到第二个分区（1GB）中。</font>**
>   >
>   >   **作业 C：800MB，可以加载到第三个分区（1GB）中。**

#### **3.动态分区分配存储管理**

**根据进程的实际需求,对内存空间进行分配回收和划分**

##### **<font color=navy>1.分区分配用数据结构</font>**

###### **1.空闲分区表**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206164131522.png" alt="image-20241206164131522" style="zoom: 80%;" />

###### **2.空闲分区链**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206164157817.png" alt="image-20241206164157817" style="zoom:80%;" />

##### **<font color=purple>2.分区分配算法</font>**

###### **1.首次适应算法FF**

**<font color=navy>(当进程请求内存时,系统会从头开始搜索空闲分区)</font>**

>   **要求空闲分区链 以地址递增次序 链接**
>
>   **缺点:查找开销大,有利于大作业分配**

###### **2.循环首次适用算法NF**

**<font color=navy>(从上次分配结束位置开始找下一个适合区域)</font>**

>   **过程:首次适用 + 起始查寻指针 + 循环查找**
>
>   **缺点:减少查找开销以及碎片化,但是不利于大作业分配**

###### **3.最佳适应算法(BF)**

**<font color=navy>空闲空间最小但又大于等于请求的空闲区域(多留了一点)</font>**

>   **过程:要求空闲分区按大小递增次序链接**
>
>   **优点:能够减少内存碎片,尽量选择合适的空闲区域**
>   
>   **缺点:会扫描所有空闲区域,效率极低,且会产生很多微小的内存碎片,导致内存的浪费**

##### **<font color=navy>3.分区分配与回收操作</font>**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206181232314.png" alt="image-20241206181232314" style="zoom:80%;" />

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206181327799.png" alt="image-20241206181327799" style="zoom:80%;" />

##### **<font color=purple>4.碎片处理</font>**

![image-20241206181344523](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206181344523.png)

#### **4.动态可重定位分配**

##### **1.紧凑技术**

**将已分配的进程进行移动,集中到内存的一侧,释放出连续的存储空间**

>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206182131606.png" alt="image-20241206182131606" style="zoom:80%;" />

##### **2.动态重定位**

**进程加载到内存,并不占用固定的内存地址,而是重映射,更加灵活地分配**

>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206182146852.png" alt="image-20241206182146852" style="zoom:80%;" />

##### **3.动态重定位分区分配算法**

**将内存分成大小不等的动态分区,进程请求适当大小的空间**

>   **之前提到的首次适用/最佳适用/循环首次适用**

##### **4.动态重定位与分区分配结合**

**结合了内存分配算法和地址重映射技术。目前最优的方式**

#### **5.对换技术与覆盖技术**

##### **1.对换的概念以及意义**

>   **概念: **
>
>   >   是指操作系统将内存中的一个或多个进程移到磁盘上，以释放内存空间，然后在需要时将这些进程再次加载到内存中。
>   >
>   >   **内存<->(进程/程序/数据)<->外存**
>   
>   **意义:提高内存利用率**

##### **2.对换实现的机制**

**UNIX(中级调度)[分为 常驻内存进程+交换进程]**

>   **过程:决定是否对换 -> 交换进程 -> 加载进程 -> 进程的交换频率**

##### **3.对换实现方式**

**进程对换(分时系统)/页面分段对换(虚拟存储技术)**

##### **4.对换空间的管理**

>   **文件区和对换区**
>
>   **<font color=navy>对换区使用情况数据结构:</font>空闲盘区表/链(盘块组为基本单位)**
>   
>   **<font color=navy>对换区分配与回收操作:</font>分配算法/分配操作/回收操作**

##### **5.进程的换出和换入**

>   **进程的换出:**
>
>   >   **1.换出的选择:进程状态 + 优先级 + 内存驻留时间**
>   >
>   >   **2.换出的过程:换出不再共享的程序或数据段 -> 对换空间申请 -> 换出 -> 内存释放**
>   
>   **进程的换入:**
>   
>   >   **1.换入的选择:进程状态 + 换出时间**
>>
>   >   **2.换入的过程:内存申请 -> 换入 -> PCB修改**

##### **6.覆盖技术**

>   **基本思想:让那些不会同时执行的程序段 共享一块内存**
>
>   (程序段:可以互相覆盖的程序/覆盖区:被公用的内存空间)
>   
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206184643129.png" alt="image-20241206184643129" style="zoom:80%;" />

#### **6.伙伴系统**

**目的:对固定分区和动态分区方式的折衷**

**分区大小:分别设立和保留大小 为基本大小(basicSize)的1倍/2倍/4倍/8倍**

**空闲分区查找算法:哈希算法<font color=navy>([$log_2(request/basicSize)$]取上界)</font>**

##### *😇**空闲分区查找计算**

>   ```TXT
>1MB     
>   896KB  -- 10  A:----    B: 
>   768KB
>   640KB
>   512KB  -- 9     ----
>   384KB
>   256KB  -- 8     ----     ----
>                           ____ 
>                        //// 
>   128KB  -- 7     ----     ----
>0KB             ////
>   
>   
>   2^10= 1024MB =1MB,所以T0时刻在位置10有时间链
>   7-> 128 -> ^
>   8-> 256 -> ^
>   9-> 512 -> ^
>   10 -> ^
>   ================================================
>   A申请96KB (96KB/1KB)=96 接近2^7
>   -> 开始查找:
>   7号8号9号空闲分区链都为空,到10显示有空闲分区,证明目前还有2^10的空闲空间
>   -> 分配:
>   1MB的空间一分为二,变为两个512KB的空间(0-512继续切割,512-1024为9的空闲空间){递归!!}
>   -> 结束:
>   直到分割的空间不小于A所申请的,就分给A,这里是 2^7 = 128 
>   //记录A(0-128)
>   此时队列:(经过分配后)其中T表示空闲空间
>   7-> T(128-256) -> ^
>   8-> T(256-512) -> ^
>   9-> T(512-1024)-> ^
>   10 -> ^
>   ================================================
>   B申请60KB (60KB/1KB)=60 接近2^6
>-> 开始查找:
>   经过A的分配后,目前分区7中还有1块128MB的空间
>-> 分配:
>   128MB一分为二(0-64分配 64-128为空闲空间)
>   -> 结束:
>   直到分割的空间不小于B所申请的,就分给B,这里是 2^6 = 64
>   //记录B(128-192)
>   6 -> T(192-256) -> ^
>   7 -> ^
>   8 -> T(256-512) -> ^
>   9 -> T(512-1024)-> ^
>   10 -> ^
>   ================================================
>   C申请78KB (78KB/1KB)=78 接近2^7
>   -> 开始查找:
>   目前分区7没有,找分区8划一半
>   -> 分配:
>   256MB一分为二(0-128分配 128-256为空闲空间)
>   -> 结束:
>   直到分割的空间不小于C所申请的,就分给C,这里是 2^7 = 128
>   //记录C(256-384)
>   6 -> T(192-256) -> ^
>   7 -> T(384-512) -> ^
>   8 -> ^
>   9 -> T(512-1024) -> ^
>   10 -> ^
>   ================================================
>   A释放:A(0-128) 回收分块7
>   6 -> T(192-256) -> ^
>   7 -> T(384-512) -> ^
>   8 -> ^
>   9 -> T(512-1024) -> ^
>   10 -> ^
>   
>   6 -> T(192-256) -> ^
>   7 -> T(0-128) -> T(384-512) -> ^
>   8 -> ^
>   9 -> T(512-1024) -> ^
>   10 -> ^
>   ================================================
>   D申请40K,40K/1k=40 2^6=64
>   所以D(192-256)
>   6 -> ^
>   7 -> T(0-128) -> T(384-512) -> ^
>   8 -> ^
>   9 -> T(512-1024) -> ^
>10 -> ^
>   ================================================
>B执行结束
>   //记录B(128-192) 64KB->2^6
>   6 -> ^
>   7 -> T(0-128) -> T(384-512) -> ^
>   8 -> ^
>   9 -> T(512-1024) -> ^
>   10 -> ^
>   
>   6 -> T(128-192)^
>   7 -> T(0-128) -> T(384-512) -> ^
>   8 -> ^
>   9 -> T(512-1024) -> ^
>   10 -> ^
>   ================================================
>D执行结束D(192-256)64k=2^6
>   
>6 -> T(128-192)^
>   7 -> T(0-128) -> T(384-512) -> ^
>   8 -> ^
>   9 -> T(512-1024) -> ^
>   10 -> ^
>   
>   6 -> T(128-256)^
>   7 -> T(0-128) -> T(384-512) -> ^
>   8 -> ^
>   9 -> T(512-1024) -> ^
>   10 -> ^
>   // 需要继续合并!!
>   6 -> ^
>   7 -> T(384-512) -> ^
>   8 -> T(0-256)
>   9 -> T(512-1024) -> ^
>   10 -> ^
>   ================================================
>   C执行结束记录,C(256-384)128K
>   6 -> ^
>   7 -> T(384-512) -> ^
>   8 -> T(0-256)
>   9 -> T(512-1024) -> ^
>   10 -> ^
>   
>   6 -> ^
>   7 -> ^
>   8 -> ^
>   9 -> ^
>   10 -> 0 -> ^
>   ```

#### **😇7.Homework!!**

###### **1.不同分配的异同**

**从内存管理的各个方面比较单一连续分配、固定分区分配、动态分区分配、动态可重定位分区等存储管理方式的异同**

>   **(特别注意相关数据结构和算法的理解)**

**单一连续分配:**
	**特点:整个内存只分配给一个进程，进程的地址空间是连续的。**
	**数据结构：只有一个进程，所以不需要复杂的数据结构。**
	**算法：通常是“首先适应（First-fit）”或者“最优适应（Best-fit）”算法。**
**固定分区分配:**
	**特点：内存被分为固定大小的分区，每个分区可以运行一个进程。**
	**数据结构：将内存划分为多个固定大小的分区，每个分区分配一个进程。**
	**算法：分配进程时使用“首先适应”或“最佳适应”等算法来选择空闲的分区。**
**动态分区分配:**
	**特点：内存根据需要动态划分，每个进程占用不同大小的内存分区。**
	**数据结构：使用链表/空闲分区链表/位图来表示内存空闲情况。**
	**算法：常见的分配算法有“首次适应（First-fit）”、“最佳适应（Best-fit）”和“最差适应（Worst-fit）”。**

**动态可重定位分区:**
	**特点：在动态分区分配的基础上，允许程序在内存中的位置动态变化**
	**数据结构：分区表、页表，硬件支持重定位寄存器。**
	**算法：当进程需要被移动时，操作系统使用"重定位机制"调整内存地址。**

###### **2.覆盖技术与对换技术**

1.  **覆盖技术（Overlay Technique）<font color=navy>(切分+加载部分整体)</font>**
    **定义：将一个较大的程序分成多个较小的模块，按需加载到内存中。**
         **程序在执行时，只有当前需要的部分会被加载，其他部分可以在不需要时被覆盖。**
    实现原理：
    **程序被划分成多个模块，操作系统会根据需要加载和覆盖这些模块。在程序运行时，系统会把某些不再需要的部分从内存中换出，把需要的部分换入。**
    应用场景：
    **用于内存有限的情况，尤其是在没有虚拟内存的早期计算机系统中。**
2.  **对换技术（Swapping Technique）<font color=navy>(换出+加载部分整体)</font>**
    定义：**将一个进程的全部或部分内容从内存中换出到磁盘中，释放内存空间，以便将其他进程的内容加载到内存中。**
    实现原理：
    操作系统会维护一个交换区，当内存不够时，会将某个进程的整个内存镜像写入磁盘，腾出内存供其他进程使用。
    当进程需要再次执行时，操作系统会将其从磁盘交换回内存。
    应用场景：
    **广泛应用于现代操作系统，尤其是在虚拟内存管理中。**

## <font color=purple>3.离散存储管理方式</font>

#### **0.分页技术**

>   **通过将内存分割成固定大小的单元来简化内存分配**
>
>   **并且允许程序使用比物理内存更大的虚拟内存空间。**

#### **1.离散存储管理方式**

>   **弊端:碎片问题以及紧凑开销**

#### **2.页面与页表**

##### **1.物理块/页面/与页表**

###### **1.物理块和页面**

>   **物理块:实际存在的固定大小的存储单元,是连续的地址区域**
>
>   **页面:虚拟内存的一个存储单元,<font color=red>大小必须和物理块相同</font>,被访问时映射到物理内存**

###### **2.内存页表(物理块表)**

>   **定义:操作系统用于管理 虚拟内存和物理内存之间映射 的关键数据结构**
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206202654893.png" alt="image-20241206202654893" style="zoom:80%;" />

###### **3.进程页表**

**页面映射表及其表项(物理块号/存取控制字段)**

>   **部分1:针对每个 进程维护的 虚拟到物理地址映射表**
>
>   **部分2:**
>   
>   **物理块号:映射到的物理内存块的编号**
>
>   **存取控制字段:描述对该页面的访问权限**
>
>   **有效位:表示该页面是否有效,页面是否已经加载到物理内存中**

###### **4.页面大小选择**

**由机器的地址结构决定,页面大/小评析($2^9 B$~8KB之间)**

![image-20241206195032428](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206195032428.png)

##### **2.位示图**

>   **利用位示图的0和1表示内存物理块的使用情况**
>
>   ![image-20241206200224170](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206200224170.png)

##### **3.物理块(盘块)的分配**

>   **``Var Map:array[m][n] of bit;``**
>
>   **1.根据需求计算需要的物理块 的个数 zKs**
>   
>   **2.找出 zKs 个值都为0的二进制位**
>
>   **3.根据公式`b = n*i + j`将找到的zKs个`Map [i][j]`对应到相应的物理块号**
>
>   **4.按物理块号分配物理块 ,同时修改位示图(Map改1)和进程页表(对应的映射)**

##### **4.物理块(盘块)的回收**

>   **1.将回收物理块的块号b转换为行号和列号(i = b DIV n;j = b MOD n;)**
>
>   **2.按物理块号回收物理块**
>   
>   **3.修改对应的位示图(Map改0)和进程页表(对应的映射)**

##### **5.😇分页存储地址结构及地址变换**

**对于64位操作系统,一般是四级页表(页全局目录/页上级目录/页中间目录/页表项)**

**<font color=navy>1.逻辑地址 页号 页内偏移地址 之间的换算</font>**

###### **1.虚拟地址 **

**<font color=red>虚拟地址= 页号 + 页内偏移量(分量->虚拟地址)只针对二进制,需要前补位</font>**

###### **2.页号**

**页号:用于定位虚拟内存空间的具体页**

###### **3.页内偏移量**

**页内偏移量:用于定位一个页内的具体位置**

(比如虚拟地址48位,假设是4KB页,所以12位(4KB=2^12)用于页内偏移量,36位用于页号)

**2.页号(十进制) = 逻辑地址(十进制) % 页大小(如果是4K,这里除以4096)[取余操作]**

>   **<font color=red>页号(十六进制) = 虚拟地址(二进制)>>页内偏移量的位数(进制位数)</font>[右移操作]**

**3.页内偏移量(十进制) = 逻辑地址(十进制) // 页大小(如果是4K,这里除以4096)[取商]**

>   **<font color=red>页内偏移量(十六进制) = 虚拟地址 & (页大小-1)</font>[按位操作]**

```TXT
虚拟地址 5292
并且假设系统使用 48位虚拟地址 和 4KB页（即页内偏移量12位）。(4页,每页1KB)
页号 = 5292 % 4096 = 1
页面偏移量 = 5292 // 4096 = 12

5292->0x14AC
5292 ÷ 16 = 330 余 12  (12 = C)
330 ÷ 16 = 20  余 10  (10 = A)
20 ÷ 16 = 1   余 4   (4 = 4)
1 ÷ 16 = 0   余 1   (1 = 1)

0001 0100 1010 1100
     1111 1111 1111
     0100 1010 1100 ->4ac ->0x4ac(页内偏移量)
右移12位:0001 ->1
```

```TXT
虚拟地址 0x123456789ABC(12位)
并且假设系统使用 48位虚拟地址 和 4KB页（即页内偏移量12位）。
=====================================================================
0x123456789ABC 是一个 48 位的十六进制数，二进制表示为：
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100

0xFFF 是 12 位的十六进制数，二进制表示为：
1111 1111 1111
!!!也就是 12 个 1，对应页内偏移量的大小（4KB 页），即 12 位。

=====================================================================
按位与（&）运算，如果两个数的对应位都是 1，则该位结果为 1，否则为 0。
 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100
 							                  1111 1111 1111
----------------------------------------------------------------------
											 1010 1011 1100  
											 8421 8421 8421
											 10   11   12   (即 0xABC)
											 所以页内偏移量是0xABC
=====================================================================
将虚拟地址右移12位：(删三位)
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100
		       0001 0010 0011 0100 0101 0110 0111 1000 1001 

0x123456789ABC >> 12 = 0x12345678（即页号为 0x12345678）。
```

****

#### **3.地址变换机构**

##### **1.基本作用**

**其基本任务是将虚拟地址（逻辑地址）转换为物理地址**

**基本组成**

>   **逻辑地址寄存器:存储虚拟地址**
>
>   **页表寄存器:存储虚拟页到物理页的映射**
>   
>   **进程页表:存储虚拟地址和物理地址的映射(每个进程都有独立的页表)**
>
>   **物理地址寄存器:存储从虚拟地址变换后 的物理地址**

**过程:逻辑地址->查询页表->计算物理地址->访问对应物理内存**

##### **2.基本的地址变换机构**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206215350223.png" alt="image-20241206215350223" style="zoom:80%;" />

##### **3.具有快表的地址变换机构**

>   **<font color=navy>快表:存储最近访问的虚拟地址到物理地址的映射</font>**
>
>   **首先查找TLB,如果TLB命中,直接获得物理地址,否则需要查页表计算物理地址**



<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206215420584.png" alt="image-20241206215420584" style="zoom:80%;" />

#### **4.两级和多级页表**

##### **1.目的**

**<font color=red>解决页表空间不足(大且需要连续)</font>**

##### **2.基本思想**

**对页表按照物理块进行分页,并且分页离散分布于不同物理块中,再用外层页表控制**

(控制方向:外层页表 -> 页表分页 -> 离散页表 -> 数据块逻辑地址)

**举例:32位,一共4G(2^32)页号,页内地址4K,所以一级页号就是4G除以4K等于1M个**

>   **但是如果是两级,对于每个分表都是4K/4=1k,需要1k个页表项即可**
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206221308075.png" alt="image-20241206221308075" style="zoom:80%;" />

##### **3.具有两级页表的地址变换结构**

>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206221341421.png" alt="image-20241206221341421" style="zoom:80%;" />

##### **4.多级页表**

**进一步的,只要不够就继续分级**

>   **对于64位:**
>
>   >   **不分级:每个进程的页表 = 2^64/4K = 2^52**
>   >
>   >   **按每个页表分页1M个页表项:外层页表的页表项 = 2^50 / 2^20 = 4G**
>>
>   >   (三级都压不住)

#### **5.反置页表**

##### **1.思想**

**一般页表->页号->物理块;反置页表->物理块->页表项**

##### **2.过程**

**使用进程标识符和页号 检索 反置页表(使用Hash检索)**

##### **3.反置页表地址变换机构**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241206222028226.png" alt="image-20241206222028226" style="zoom:80%;" />

#### **😇6.Homework!!**

**从内存管理的各个方面谈谈你对基本分页存储管理方式的认识与理解，包括相关数据结构和算法、页面大小选择、多级页表和反置页表等。**

基本分页存储管理通过将物理内存和进程的逻辑地址空间都划分为固定大小的页面（Page）和页框（Frame）

目的:解决程序中不连续内存分配的问题。

1. 基本分页的基本原理
    虚拟内存分页：每个进程的虚拟地址空间被分为多个固定大小的页（Page），每个页的大小是预定的固定值
    页表：虚拟页面与物理页面的映射关系。 
    地址转换：当进程访问内存时，操作系统使用页表将虚拟地址转换为物理地址。
    页内偏移（Offset）：表示进程内存中该页内的具体位置。 
2. 相关数据结构与算法
    页表（Page Table）：存储虚拟页到物理页的映射关系。 
    页表项（Page Table Entry, PTE）：页表项不仅包含物理页面的框号，还可能包含一些附加信息，如有效位、修改位、访问权限等。 
    地址转换算法：
    直接映射：虚拟页号直接通过页表查找映射的物理页框号。 
    多级页表（Multi-level Page Table）：当页表过大时，采用多级页表结构来减小内存的占用。 

3. 页面大小的选择
页面大小的选择直接影响系统的性能和内存管理的效率。
小页面：减少内部碎片,减少浪费。 增加页表的大小和管理开销，因为需要更多的页表项。 
大页面：减少页表的大小，但较大的页面容易产生内部碎片（每个进程分配了更多的内存，可能并未完全使用）。 

4. 多级页表（Multi-level Page Table）通过将页表本身分成多个层级来实现。
5. 反置页表（Inverted Page Table）其与传统的页表结构不同，采用反向映射方式。
原理：
    在反置页表中，页表的每一项不再存储 虚拟页号到物理页框号的映射，而是存储 物理页框号到虚拟页号的映射。 
    反置页表中的项是针对每个物理页框而存在的，而不是针对每个虚拟页。 
节省空间：反置页表的大小只与物理内存大小有关，而不受进程虚拟内存空间大小的影响。



## **<font color=purple>4.基本 分段存储管理方式</font>**

#### **1.分段存储管理方式的引入**

>   **目的:面对用户友好/为了信息共享信息保护动态链接/动态增长**
>
>   **<font color=navy>(分段作为信息的逻辑单位)</font>**

#### **2.分段系统的基本原理**

>   **作业地址空间被划分成若干段,每个段定义了一组逻辑信息(比如主程序/子程序/数据段/栈段)**
>
>   **每个段都从0开始编码,且采用连续一段的地址空间,<font color=navy>长度取决于对应逻辑信息组的长度</font>**
>
>   **整个作业的地址空间"是二维的",作业的逻辑地址由 段号(名)和段内地址 组成**
>
>   **<font color=red>分页的每个空间是相同且固定的,分段的每个大小是动态的</font>**
>
>   **<font color=red>分页的逻辑地址是单维的(页号+页内偏移),分段二维的(短号+段内地址)</font>**
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207084615881.png" alt="image-20241207084615881" style="zoom:80%;" />
>
>   **分段系统地址的变换机构**
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207084839368.png" alt="image-20241207084839368" style="zoom:80%;" />
>
>   **分页和分段的 "存储管理" 比较:**
>
>   >   **相同处:都是离散分配/都有地址变换机构**
>   >
>   >   **不同处:**
>   >
>   >   **前者系统管理需要 后者用户需要**
>   >
>   >   **前者长度固定(一维) 后者长度不固定(二维)**

#### **3.信息共享**

>   **可重入代码:一种允许多个进程同时访问的代码(且不允许任何进程对它进行修改)**
>
>   ```TXT
>   某多用户系统，可同时接纳40个用户，假设均在执行Editor进行文本编辑。
>   
>   若该文本编辑程序含有160KB的代码区和40KB的数据区，则总共需有8000KB的内存空间来支持
>   
>   如果该文本编辑程序代码是可重入的，则无论分页系统还是分段系统该程序代码都能被共享，即内存中只需保留一份文本编辑程序的副本，
>   
>   因而所需内存空间仅为40×40+160=1760KB
>   ```

#### **4.段页式存储管理方式**

>   **引入:分页提高内存利用率/分段能满足用户需求->两者结合**
>
>   **操作:将用户程序按信息性质分为若干段,再把段划为若干页**
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207090710338.png" alt="image-20241207090710338" style="zoom:80%;" />
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207090729813.png" alt="image-20241207090729813" style="zoom:80%;" />
>
>   **段页的地址变换机构**
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207090950677.png" alt="image-20241207090950677" style="zoom:80%;" />

#### **😇5.Homework!!**

```TXT
分段存储管理是一种将程序的地址空间划分为若干逻辑段（segment）的存储管理方式。
每个段都包含了一个特定类型的数据，如代码段、数据段、堆栈段等。
分段的目的是根据程序的逻辑结构进行内存分配，使得每个段的大小和地址可以独立管理，从而提高程序的灵活性。

相关数据结构与算法
段表（Segment Table）：段表是操作系统用来管理分段内存的关键数据结构。每个进程通常有一个段表来管理其所有段。
段基址（Segment Base Address）：指向段在物理内存中的起始位置，用来计算该段内的偏移地址。
段限长（Segment Limit）：记录段的大小，限制访问超出该段范围的内存地址。

基本原理
逻辑地址分解：分段系统中的逻辑地址通常由段号和段内偏移组成，即逻辑地址 = (段号+段内偏移)。
内存保护：通过检查段内偏移是否超出段的大小限制，防止程序访问非法内存区域，从而提供内存保护。
动态分配：分段管理不要求每个段的大小相同，因此可以根据程序的实际需求动态分配内存，这对程序的内存利用率较高。
```



<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207184010803.png" alt="image-20241207184010803" style="zoom:50%;" />

## **<font color=purple>5.虚拟存储器概念及关键技术</font>**

#### **0.引入**

**如果要求将一个作业全部装入内存中才能运行->提高内存容量 or 设置虚拟存储技术**

**局部性原理:在一个较短时间内,程序的执行仅限于某个部分(时间局限性/空间局限性)**

**(它所访问的内存空间页会局限于某个区域)<font color=red>(只是逻辑上扩充)</font>**

**技术要点:**

>   **作业装入内存即可运行,其余部分暂存磁盘**
>
>   **程序执行过程以及机制:已经调入内存的直接访问/未调入的中断并请求调入/页段置换**
>
>   **<font color=red>页段置换和页段对换:</font>**
>
>   >   **页段置换:是分页存储的概念:**
>   >
>   >   **由于物理内存空间有限,并不总是完全加载到内存中,则从内存中换出该页面**
>   >
>   >   **页段对换:一种分段存储方式:**
>   >
>   >   **由于物理内存空间有限,操作系统通过某种方式选择一个段将其移出内存**

#### **1.虚拟存储器的定义**

##### **<font color=navy>1.虚拟存储器</font>**

**将作业的一部分装入内存便可以运行的存储器系统**

>   **具有请求调入功能和置换功能,从逻辑上对内存容量进行扩充(其实还是内存和外存一起)**

##### **<font color=navy>2.请求分页虚拟存储系统的功能</font>**

>   **技术构成:分页 + 请求调页 + 页面置换**
>
>   **硬件:请求分页的页表机制 / 缺页中断机构 / 地址变换机构**
>
>   **软件:请求调换 / 页面置换**

##### **<font color=navy>3.虚拟存储器的特征</font>**

>   **离散型/多次性/对换性/虚拟性**

## **<font color=purple>6.请求分页存储管理方式</font>**

#### **1.请求分页中的硬件支持**

##### **0.虚拟内存管理页表组成:**

**存在位:用于指示 当前虚拟页面 是否被加载到 物理内存中,用1和0表示**

**修改位:用于指示 当前页面 是否被修改 用1和0表示**

**访问位:用于表示 当前页面 是否被访问过**

**权限位:可读/可写/可执行**

##### **1.过程**

**地址分解为页表和偏移->查找页表->直接访问物理内存/加载到内存->更新映射和存在修改位**



<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207105234239.png" alt="image-20241207105234239" style="zoom:80%;" />

##### **2.缺页中断机构**

>   **缺页中断的中断特征:保护CPU现场/分析中断原因/转入中断处理程序/恢复现场**
>
>   **特殊性:在指令执行期间产生和处理中断信号;一条指令执行期间可能产生多次缺页中断**

##### **3.地址变换机构**

###### **1.组成**

**分页系统的地址变换机构 + 缺页中断产生+处理页面置换功能**

**如果未调入内存,产生缺页中断,并请求操作系统从外存调入内存**

###### **<font color=navy>2.请求分页系统地址变换过程</font>**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207120334478.png" alt="image-20241207120334478" style="zoom:80%;" />

###### **<font color=navy>3.缺页中断处理算法流程</font>**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207120444218.png" alt="image-20241207120444218" style="zoom:80%;" />

#### **2.内存分配策略和分配算法**

##### **1.确定最小物理块数算法**

**保证进程正常运行所需的最少物理块数**

>   **原因:如果为某进程分配的物理块数少于此值,进程将无法运行**
>
>   **相关性:硬件结构,操作数个数,功能和寻址方式**

##### **2.物理块分配与置换策略**

>   **固定分配局部置换:为每个进程分配一个固定页数的存储空间,整个运行期间都不再改变**
>
>   **可变分配全局置换:系统设立一个空闲的物理块队列,缺页触发全局新增分配或全局置换**
>
>   **可变分配局部置换:根据缺页率的增加 增加或减少物理块**

##### **3.物理块分配算法**

>   **1.平均分配算法:将系统可供分配的物理块平均分配**
>
>   **2.按比例分配算法:介于物理内存块数和最小值之间的最大者**
>
>   >   **$$BlockOfP_k = max(min(minBlocks,\frac{Blocks \times PageOfP_k}{\sum PageOfP_i}[进程的页面数占总页数的比例]))$$**
>
>   **3.考虑优先权的分配算法:考虑重要的作业**

#### **3.调页策略**

**(面对进程需要的文件,从文件区导对换区)**

##### **1.调入页面的策略**

>   **预调页策略:将不久之后 将访问的程序或数据 所在的页面,预先调入内存**
>
>   **请求调页策略:进程运行时需要某些数据时 立即发出请求并且调入内存**

##### **2.调入页面的过程**

>   **缺页中断的发生:程序访问的页面不在内存时,产生缺页中断,转入缺页中断程序**
>
>   **根据页表 给定的外存地址(物理盘块号) 调入所缺页面**
>
>   **内存不足置换:页面淘汰算法/是否重写磁盘**

##### **3.调入页面的结果**

>   **对换区空间充分:进程运行前,将需要的文件,从文件区拷贝到对换区**
>
>   **对换区空间不足:文件是否修改为分别处理**
>
>   **Unix中级交换调度(面对反复从文件区到对换区)**

#### **😇4.页面淘汰算法**

##### **1.抖动率与缺页率**

>   **抖动:如果淘汰算法使用不当,刚换出的页面又被访问,又被调入(类似抽动的现象)**
>
>   **缺页率 = 缺页中断次数 / 页面访问次数**

##### **2.最佳淘汰算法OPT**

>   **基本思想:选择 永不使用/最长时间内不再访问的页面 淘汰出内存**
>
>   **具有最好的性能(即获得最低的缺页率)**
>
>   ```TXT
>   给定页面访问序列:	
>   7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1
>   (假设该进程分配了三个物理块,因此一开始分配给最先的三个页面)
>   
>   当前访问  物理块序列
>   7	T0:7
>   0	T1:7 0 
>   1	T2:7 0 1
>   2	T3:2 0 1 (距离下一个7比距离下一个01远,所以换掉7)
>   3	T4:2 0 3 (距离下一个1比距离下一个02远,所以换掉1)
>   0   T5:2 0 3
>   4   T6:2 4 3 (距离下一个0比距离下一个23远,所以换掉0)
>   2	T7:2 4 3 
>   3	T8:2 4 3
>   0	T9:2 0 3 (距离下一个4比距离下一个23远,所以换掉4)
>   3   T10:2 0 3
>   2	T11:2 0 3
>   1	T12:2 0 1(距离下一个3比距离下一个20远,所以换掉3)
>   2	T13:2 0 1
>   0	T14:2 0 1
>   1	T15:2 0 1
>   7	T16:7 0 1(距离下一个2比距离下一个10远,所以换掉2)
>   0   T17:7 0 1
>   1	T18:7 0 1
>   
>   // 经过了6次缺页中断,缺页率为30%
>   ```

##### **3.先进先出淘汰算法FIFO**

>   **基本思想:选择最先进入内存的换出到外存.**
>
>   **具体实现:形成一个队列,并且设置淘汰指针**
>
>   **评价:理论上简单,但性能较差**
>
>   ```TXT
>   给定页面访问序列:	
>   7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1
>   (假设该进程分配了三个物理块,因此一开始分配给最先的三个页面)
>   
>   当前访问  物理块序列
>   7	T0:7
>   0	T1:7 0 
>   1	T2:7 0 1
>   2	T3:2 0 1 (FIFO,换掉最早的7) 
>   3	T4:2 3 1 (FIFO)
>   0   T5:2 3 0 (FIFO)
>   4   T6:4 3 0 (FIFO)
>   2	T7:4 2 0 (FIFO)
>   3	T8:4 2 3 (FIFO)
>   0	T9:0 2 3 (FIFO)
>   3   T10:0 2 3
>   2	T11:0 2 3
>   1	T12:0 1 3(FIFO)
>   2	T13:0 1 2(FIFO)
>   0	T14:0 1 2
>   1	T15:0 1 2
>   7	T16:7 1 2(FIFO)
>   0   T17:7 0 2(FIFO)
>   1	T18:7 0 1(FIFO)
>   
>   // 经过了12次缺页中断,缺页率为60%
>   ```

##### **4.最长时间未使用淘汰算法LRU**

>   **基本思想:最长时间未被淘汰的页面淘汰出页面**
>
>   **评价:性能较好,但是需要大量硬件支持(移位寄存器/栈)**
>
>   ```TXT
>   给定页面访问序列:	
>   7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1
>   (假设该进程分配了三个物理块,因此一开始分配给最先的三个页面)
>   
>   当前访问  			 物理块序列            访问时间   
>   7					T0:7                (0)         
>   0					T1:7 0              (1,0)
>   1					T2:7 0 1            (2,1,0)
>   2					T3:2 0 1 (LRU)      (0,2,1)
>   0                   T4:2 0 1            (1,0(reset),2)
>   3                   T5:2 0 3 (LRU)      (2,1,0)
>   0                   T6:2 0 3            (3,0(reset),1)
>   4                   T7:4 0 3 (LRU)      (0,1,2)
>   2                   T8:4 0 2 (LRU)      (1,2,0)
>   3                   T9:4 3 2 (LRU)      (2,0,1)
>   0                   T10:0 3 2 (LRU)     (0,1,2)
>   3                   T11:0 3 2           (1,0,3)
>   2                   T12:0 3 2           (2,1,0)
>   1                   T13:1 3 2 (LRU)     (0,2,1)
>   2                   T14:1 3 2           (1,3,0)
>   0                   T15:1 0 2 (LRU)     (2,0,1)
>   1                   T16:1 0 2           (0,1,2)
>   7                   T17:1 0 7 (LRU)     (1,2,0)
>   0                   T18:1 0 7           (2,0,1)
>   1                   T19:1 0 7           (3,1,0)
>   // 经过了9次缺页中断,缺页率为45%
>   ```

##### **5.时钟式淘汰算法**

>   **基本思想:**
>
>   >   **步骤1:从起始开始扫描循环队列,选择访问位为0和修改位为0的进程(没有转步骤2)**
>   >
>   >   **步骤2:如果修改位都是1,那么再找访问位为0的进行淘汰(没有转步骤1)**

<img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207152749110.png" alt="image-20241207152749110" style="zoom:80%;" />

##### **6.最少使用淘汰算法LFU**

>   **基本思想:为内存各页设置一个移位寄存器(用于记录被访问),选择最近使用最少的页面**

##### **7.页面缓冲算法PBA**

>   **基本思想:**
>
>   **相关数据结构:设立空闲页面链表(物理块分配)和已修改页面链表(总结,到一定上限后写回)**
>
>   **相关算法:局部FIFO,但是不被淘汰,而是在两个链表的最后挂起**

#### **!!!!!😇5.Homework!!**

9 试从内存分配、页表机制、地址变换、缺页中断以及调页过程等方面谈谈你对请求分页存储管理系统的认识与理解。

请求分页存储管理（Demand Paging）是一种按需加载分页技术
程序在执行时，并不会将所有的页面都加载到内存中，而是当程序需要访问某个页面时，操作系统才会将该页面从外存加载到内存中。

1. 内存分配
按需分配：内存中的页面是根据程序运行时的需要动态加载的，初始时只有少部分页面被加载到内存
页面粒度：内存分配是基于页面的，每个页面大小固定，这使得内存分配更加灵活，且能够减少内存碎片。
2. 页表机制:管理虚拟地址到物理地址映射的关键数据结构,记录每个页面的状态。 
3. 地址变换逻辑地址到物理地址：当程序访问某个虚拟地址时，硬件或操作系统会通过页表将虚拟地址转换为物理地址。
   页表查找：在请求分页系统中，如果缺页，操作系统就会触发缺页中断来加载缺失的页面。 
4. 缺页中断
缺页中断的触发：当程序访问一个不在内存中的页面时，会发生缺页中断。操作系统捕获到缺页中断后，执行缺页处理流程。 
缺页处理过程：中断处理/页面调度/更新页表
5. 调页过程
页面置换：为了加载缺失的页面，选择一个页面进行置换。常见的页面置换算法包括最久未使用（LRU）、先进先出（FIFO）等。 

总结
**请求分页存储管理通过按需加载页面来减少内存占用，并通过页表进行地址变换和管理。缺页中断和调页机制使得系统可以动态地将程序所需的页面从磁盘加载到内存，但也可能带来I/O开销，尤其是在缺页率较高时。**

***

10 什么是抖动？如何计算缺页率？阐述和比较各种页面淘汰算法的基本流程和实现要领。(略)

***

```TXT
4.11[必做] 某虚拟存储器的用户空间共有32个页面，每页1KB，主存16KB。假定某时刻系统为用户的第0、1、2、3页分别分配的物理块号为5、10、4、7，用户的作业长为6页,将虚拟地址0A5C\103C\1A5C变换为物理地址。

解:1KB = 2^10,所以页内偏移量为10位,因为一共就32K页面:2^15,所以就取15位
0A5C:000 1010 0101 1100 
093C:000 1001 0011 1100

对于0A5C:000 1010 0101 1100  前5位为页号,后10位为偏移量 (00010)_2,(1001011100)_2
从右往左:0*2^0+1*2^1+0*2^2....=2,所以页号为4,对应(0100)_2
映射的物理块号的二进制和偏移量结合:(00)01 0010 0101 1100,即125C(后移前补0)

对于103C: (0)001 0000 0011 1100  前5位为页号,后10位为偏移量
页号:00100 即2^2*1 = 4 < 5(0~5),但是页号4无对应关系
// 页号合法,但是该页未装入内存(没有映射关系),缺页中断

对于1A5C:(0)001 1010 0101 1100 前5位为页号,后10位为偏移量
页号:00110,即2^2*1+2^1*1 = 4+2 = 6 >5(0~5)
// 页号为6不合法,越界错误



4.12[必做]某请求分页系统中,假定一个作业的页面走向为1,2,3,4,1,2,5,1,2,3,4,5,目前它还没有任何页装入内存,当分配给该作业的物理块数目M分别为3和4时,计算采用FIFO过程中的缺页次数,是否有异常

当前访问		物理块序列(M=3)			物理块序列(M=4)
1				1							1
2				1,2							1,2
3				1,2,3						1,2,3
4				2,3,4(FIFO)					1,2,3,4
1				3,4,1(FIFO)					1,2,3,4
2				4,1,2(FIFO)					1,2,3,4
5				1,2,5(FIFO)					2,3,4,5(FIFO)
1				1,2,5						3,4,5,1(FIFO)
2				1,2,5						4,5,1,2(FIFO)
3				2,5,3(FIFO)					5,1,2,3(FIFO)
4				5,3,4(FIFO)					1,2,3,4(FIFO)
5				5,3,4						2,3,4,5(FIFO)
总查询:12次		 缺页次数:6次,50%			 缺页次数:6次,50%

这种增大框架数但是不改善情况的反intuition的现象:Belady's Anomaly
```





## **<font color=purple>7.请求分段存储管理方式</font>**

#### **1.请求分段中的硬件支持**

>   **段表机制:拓充为三项:段号/段长/分段基址**
>
>   **地址变换机构:在分段系统地址变换机构+缺段中断+分段置换**
>
>   **过程:段表找到对应分段的段表项,若未调入内存,产生缺段中断,请求操作系统把该段调入内存**
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207160050064.png" alt="image-20241207160050064" style="zoom:80%;" />
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207160108987.png" alt="image-20241207160108987" style="zoom:80%;" />

#### **2.分段共享**

>   **共享段表:共享进程计数/存取控制字段/共享段不同段号**
>
>   >   **<font color=pink>(粉色部分 为 分段共享进程描述)</font>**
>
>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207160207061.png" alt="image-20241207160207061" style="zoom:80%;" />
>
>   **共享段的分配与回收**
>
>   >   **共享段的分配:**
>   >
>   >   **对于第一个请求使用某共享段的进程,系统为该共享段进行内存区的分配与装入**
>   >
>   >   >   **(共享段信息 填入 对应进程的段表)**
>   >
>   >   **之后的请求:修改对应 进程段表表项 以及 共享段表表项 即可**
>   >
>   >   ****
>   >
>   >   **共享段的回收:恰好相反**

#### **3.分段保护**

**越界检查/权限检查/环保护机构**

>   <img src="F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207160704491.png" alt="image-20241207160704491" style="zoom:80%;" />

#### **4.x86体系中请求段页式支撑机制**

![image-20241207160722433](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207160722433.png)

![image-20241207160732665](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207160732665.png)

![image-20241207160740136](F:\desktop\期末复习用\大二上\操作系统\md\assets\image-20241207160740136.png)



