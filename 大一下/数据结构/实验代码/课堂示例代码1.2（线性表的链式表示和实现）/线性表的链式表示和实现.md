#
## 线性表的链式表示和实现
### 单链表的定义和表示
```cpp

```
#### 问题1：typedef Node *Linklist;
Linklist是指向首元节点的首指针
在常见的链表操作函数中，通常会将链表的首指针作为参数传递进去，以便从头开始执行操作。

例如，InitList() 函数用于初始化链表，通常会接受一个 Linklist 类型的参数，该参数是链表的首指针。在函数内部，可以通过该首指针来操作链表的头部，并进行初始化操作。

类似地，GetElem() 函数用于获取链表中指定位置的元素值，通常也会接受一个 Linklist 类型的参数，该参数是链表的首指针。通过该首指针，可以遍历链表，找到指定位置的节点，并返回其元素值。

ListInsert() 函数用于在链表中插入一个新节点，同样也会接受一个 Linklist 类型的参数作为首指针。通过该首指针，可以找到插入位置的节点，并进行节点的插入操作。

总之，这些函数的参数 LinkList& L 实际上都是用来操作链表的首指针，从而对整个链表进行操作。


#### 使用指针作为链表的首指针有几个好处：

动态内存分配：链表通常需要在运行时动态地创建和删除节点。使用指针作为首指针可以方便地进行内存分配和释放。通过动态分配内存，可以根据需要创建节点，并将其连接起来，而无需预先定义节点的数量。

灵活性和扩展性：使用指针作为首指针可以轻松地在链表的任何位置进行插入、删除和修改操作。通过修改指针的指向，可以改变节点之间的连接关系，实现各种链表操作。

节省内存空间：如果直接引用节点结构体作为链表的首节点，每次传递该节点作为参数时都会复制整个节点的内容，包括数据域和指针域。而使用指针作为首指针，只需传递指针的地址，可以节省内存空间并提高效率。

总之，使用指针作为链表的首指针可以提供更大的灵活性、动态性和节省内存的优势，使链表操作更加方便和高效。

#### 问题2：链表的建立
过程是：在初始化（构造空格的时候）L = new Node;
L->next = NULL;的意思是构造一个首元节点赋给头指针（让头指针指像首元节点），这个时候在新node'上再生成一个指针指向NULL。
也就是说在链表的建立和操作过程中，通常会保持一个指针指向链表的最后一个节点的下一个位置，也就是 NULL 区域。这样做可以方便进行链表的扩展和连接。

所以如果没有指像NULL可能就会形成野指针的致命错误
所以当链表的最后一个节点的指针域不是明确指向 NULL，而是指向了随机的内存地址或已释放的内存区域时，后续对链表的操作就会出现问题。这样的指针被称为野指针，因为它指向的内存位置是不可预测的。

**所以在进行链表操作时，常常会遍历链表，通过检查节点的指针域是否为 NULL 来确定是否到达链表的末尾。**
如果最后一个节点的指针域没有正确地指向 NULL，那么遍历过程可能会继续向下遍历，访问到无效的内存地址，导致程序崩溃或产生不可预测的行为。

#### 问题3：元素获取
#### 引用参数时Linklist并不是引用的原因？
你的猜测是正确的。在 GetElem() 函数中，将 Linklist L 参数声明为非引用的原因是为了避免意外改变指向前一个节点的指针。

在获取链表中指定位置的元素时，通常需要遍历链表，逐个访问节点直到达到目标位置。如果将 Linklist L 参数声明为引用，那么在遍历过程中，如果不小心修改了 L 所指向的节点的指针域，可能会导致链表结构的破坏或出现意外行为。

通过将 Linklist L 参数声明为非引用，函数可以接受链表的首指针，但无法直接修改指针本身。这样可以避免在 GetElem() 函数中修改指向前一个节点的指针，从而确保链表的结构不受影响。

另外，需要注意的是，虽然 Linklist L 参数没有使用引用，但函数内部仍然可以通过 L 来访问链表节点的数据域和指针域，以进行元素的查找操作。
#### 引用参数时Elemtype &e的引用？
在 GetElem() 函数中，Elemtype& e 参数的引用允许我们将找到的元素的值通过参数返回给调用者，而无需使用函数的返回值。通过使用引用，可以直接修改调用者提供的变量，以便在函数执行后获取所需的元素值。

通过将 Elemtype& e 参数声明为引用，可以在函数内部通过对 e 的操作来修改调用者提供的变量。这样，当在链表中找到指定位置的元素时，可以将其值存储在 e 中，并将其传递给调用者。
#### 如果我新创建了一个节点p，那么while(p)其实是while(p!=NULL)
是的，你是正确的。在 C/C++ 的条件语句中，while(p) 实际上是在判断 p 是否为 NULL。它等效于 while(p != NULL) 或者 while(p != nullptr)。

当 p 是一个指针类型时，while(p) 将检查指针 p 是否为 NULL，即判断指针是否指向有效的内存地址。如果 p 是 NULL，则条件为假，循环终止；如果 p 不是 NULL，则条件为真，循环继续执行。

因此，while(p) 可以用作链表遍历中的条件判断，循环将在 p 指向链表的最后一个节点之后终止。

注意，在使用 while(p) 进行链表遍历时，确保在循环体内更新 p 的值，使其指向下一个节点，以避免进入无限循环。例如，可以使用 p = p->next; 将 p 更新为链表中的下一个节点。
#### 写改删查通用的首元节点的创造：
在链表的写、改、删、查等操作中，**通常的第一步是创建首元节点并设置其指针域（next）。**

创建首元节点的目的是建立链表的起始点，并且该节点通常不存储实际的数据。它的作用是作为链表的头部，方便对链表的操作和遍历。

在创建首元节点时，需要注意以下几点：

分配内存：使用 new 运算符或其他方式在堆上分配内存，创建一个新节点。例如：Node* head = new Node;

初始化数据：根据你的需求，可以为首元节点设置默认的数据值（如果有的话）。例如：head->data = defaultValue;

设置指针域：将首元节点的指针域 next 设置为指向下一个节点的指针。通常在初始情况下，链表为空，所以可以将指针域设置为 nullptr 或 NULL，表示没有下一个节点。例如：head->next = nullptr;

通过以上步骤，我们成功创建了首元节点，并且设置了其指针域。